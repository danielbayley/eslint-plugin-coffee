// Generated by CoffeeScript 2.3.1
(function() {
  /**
   * @fileoverview Common utils for AST.
   * @author Gyandeep Singh
   */
  'use strict';
  /**
   * Gets the name and kind of the given function node.
   *
   * - `function foo() {}`  .................... `function 'foo'`
   * - `(function foo() {})`  .................. `function 'foo'`
   * - `(function() {})`  ...................... `function`
   * - `function* foo() {}`  ................... `generator function 'foo'`
   * - `(function* foo() {})`  ................. `generator function 'foo'`
   * - `(function*() {})`  ..................... `generator function`
   * - `() => {}`  ............................. `arrow function`
   * - `async () => {}`  ....................... `async arrow function`
   * - `({ foo: function foo() {} })`  ......... `method 'foo'`
   * - `({ foo: function() {} })`  ............. `method 'foo'`
   * - `({ ['foo']: function() {} })`  ......... `method 'foo'`
   * - `({ [foo]: function() {} })`  ........... `method`
   * - `({ foo() {} })`  ....................... `method 'foo'`
   * - `({ foo: function* foo() {} })`  ........ `generator method 'foo'`
   * - `({ foo: function*() {} })`  ............ `generator method 'foo'`
   * - `({ ['foo']: function*() {} })`  ........ `generator method 'foo'`
   * - `({ [foo]: function*() {} })`  .......... `generator method`
   * - `({ *foo() {} })`  ...................... `generator method 'foo'`
   * - `({ foo: async function foo() {} })`  ... `async method 'foo'`
   * - `({ foo: async function() {} })`  ....... `async method 'foo'`
   * - `({ ['foo']: async function() {} })`  ... `async method 'foo'`
   * - `({ [foo]: async function() {} })`  ..... `async method`
   * - `({ async foo() {} })`  ................. `async method 'foo'`
   * - `({ get foo() {} })`  ................... `getter 'foo'`
   * - `({ set foo(a) {} })`  .................. `setter 'foo'`
   * - `class A { constructor() {} }`  ......... `constructor`
   * - `class A { foo() {} }`  ................. `method 'foo'`
   * - `class A { *foo() {} }`  ................ `generator method 'foo'`
   * - `class A { async foo() {} }`  ........... `async method 'foo'`
   * - `class A { ['foo']() {} }`  ............. `method 'foo'`
   * - `class A { *['foo']() {} }`  ............ `generator method 'foo'`
   * - `class A { async ['foo']() {} }`  ....... `async method 'foo'`
   * - `class A { [foo]() {} }`  ............... `method`
   * - `class A { *[foo]() {} }`  .............. `generator method`
   * - `class A { async [foo]() {} }`  ......... `async method`
   * - `class A { get foo() {} }`  ............. `getter 'foo'`
   * - `class A { set foo(a) {} }`  ............ `setter 'foo'`
   * - `class A { static foo() {} }`  .......... `static method 'foo'`
   * - `class A { static *foo() {} }`  ......... `static generator method 'foo'`
   * - `class A { static async foo() {} }`  .... `static async method 'foo'`
   * - `class A { static get foo() {} }`  ...... `static getter 'foo'`
   * - `class A { static set foo(a) {} }`  ..... `static setter 'foo'`
   *
   * @param {ASTNode} node - The function node to get.
   * @returns {string} The name and kind of the function node.
   */
  var anyLoopPattern, astUtils, getFunctionName, getFunctionNameWithKind, getPrecedence, getStaticPropertyName, isIife, isInLoop, isLoop;

  astUtils = require('eslint/lib/ast-utils');

  ({getStaticPropertyName} = astUtils);

  anyLoopPattern = /^WhileStatement|For$/;

  //------------------------------------------------------------------------------
  // Public Interface
  //------------------------------------------------------------------------------
  /**
   * Get the precedence level based on the node type
   * @param {ASTNode} node node to evaluate
   * @returns {int} precedence level
   * @private
   */
  getPrecedence = function(node) {
    switch (node.type) {
      // when 'SequenceExpression'
      //   return 0
      case 'AssignmentExpression': // ,'ArrowFunctionExpression', 'YieldExpression'
        return 1;
      // when 'ConditionalExpression'
      //   return 3
      case 'LogicalExpression':
        switch (node.operator) {
          case '?':
            return 3;
          case '||':
          case 'or':
            return 4;
          case '&&':
          case 'and':
            return 5;
        }
        break;
      // no default
      /* falls through */
      case 'BinaryExpression':
        switch (node.operator) {
          case '|':
            return 6;
          case '^':
            return 7;
          case '&':
            return 8;
          case '==':
          case '!=':
          case '===':
          case '!==':
            return 9;
          case '<':
          case '<=':
          case '>':
          case '>=':
          case 'in':
          case 'instanceof':
            return 10;
          case '<<':
          case '>>':
          case '>>>':
            return 11;
          case '+':
          case '-':
            return 12;
          case '*':
          case '/':
          case '%':
            return 13;
          case '**':
            return 15;
        }
    }
  };

  // no default
  /* falls through */
  // when 'UnaryExpression', 'AwaitExpression'
  //   return 16
  // when 'UpdateExpression'
  //   return 17
  // when 'CallExpression'
  //   return 18
  // when 'NewExpression'
  //   return 19
  // else
  //   return 20
  isLoop = function(node) {
    return !!(node && anyLoopPattern.test(node.type));
  };

  isInLoop = function(node) {
    var currentNode;
    currentNode = node;
    while (currentNode && !astUtils.isFunction(currentNode)) {
      if (isLoop(currentNode)) {
        return true;
      }
      currentNode = currentNode.parent;
    }
    return false;
  };

  getFunctionName = function(node) {
    if (!((node != null ? node.type : void 0) === 'FunctionExpression' && node.parent.type === 'AssignmentExpression' && node.parent.left.type === 'Identifier')) {
      return null;
    }
    return node.parent.left.name;
  };

  getFunctionNameWithKind = function(node) {
    var name, parent, ref, tokens;
    ({parent} = node);
    tokens = [];
    if (parent.type === 'MethodDefinition' && parent.static) {
      tokens.push('static');
    }
    if (node.async) {
      tokens.push('async');
    }
    if (node.generator) {
      tokens.push('generator');
    }
    if (node.type === 'ArrowFunctionExpression') {
      tokens.push('arrow', 'function');
    } else if ((ref = parent.type) === 'Property' || ref === 'MethodDefinition') {
      if (parent.kind === 'constructor') {
        return 'constructor';
      }
      if (parent.kind === 'get') {
        tokens.push('getter');
      } else if (parent.kind === 'set') {
        tokens.push('setter');
      } else {
        tokens.push('method');
      }
    } else {
      tokens.push('function');
    }
    name = getFunctionName(node);
    if (name == null) {
      name = getStaticPropertyName(parent);
    }
    if (name) {
      tokens.push(`'${name}'`);
    }
    return tokens.join(' ');
  };

  isIife = function(func) {
    if ((func != null ? func.type : void 0) !== 'FunctionExpression') {
      return false;
    }
    if (func.parent.type === 'UnaryExpression' && func.parent.operator === 'do') {
      return true;
    }
    if (func.parent.type === 'CallExpression' && func.parent.callee === func) {
      return true;
    }
    return false;
  };

  module.exports = {getPrecedence, isInLoop, getFunctionName, getFunctionNameWithKind, isIife};

}).call(this);
