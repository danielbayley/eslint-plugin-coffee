// Generated by CoffeeScript 2.3.1
(function() {
  var CodePathAnalyzer, CoffeeScript, KEYS, analyzeScope, babelTraverse, babylonToEspree, babylonTokenTypes, espreeTokenTypes, extend, extendVisitorKeys, flatten, getEspreeTokenType, getParser, locationDataToAst, tokensForESLint;

  CoffeeScript = require('coffeescript');

  // traverseBabylonAst
  ({locationDataToAst} = require('coffeescript/lib/coffeescript/helpers'));

  // babylonToEspree = require '../node_modules/babel-eslint/babylon-to-espree'
  babylonToEspree = require('babel-eslint/babylon-to-espree');

  babelTraverse = require('babel-traverse').default;

  babylonTokenTypes = require('babylon').tokTypes;

  ({
    flatten,
    assign: extend
  } = require('lodash'));

  // patchCodePathAnalysis = require './patch-code-path-analysis'
  analyzeScope = require('./analyze-scope');

  CodePathAnalyzer = require('./code-path-analysis/code-path-analyzer');

  ({KEYS} = require('eslint-visitor-keys'));

  extendVisitorKeys = function() {
    var t;
    t = require('babel-types');
    return extend(t.VISITOR_KEYS, {
      For: ['index', 'name', 'source', 'step', 'guard', 'body'],
      InterpolatedRegExpLiteral: ['expressions'],
      Range: ['from', 'to']
    });
  };

  espreeTokenTypes = {
    '{': 'Punctuator',
    '}': 'Punctuator',
    '[': 'Punctuator',
    ']': 'Punctuator',
    '(': 'Punctuator',
    ')': 'Punctuator',
    CALL_START: 'Punctuator',
    CALL_END: 'Punctuator',
    PARAM_START: 'Punctuator',
    PARAM_END: 'Punctuator',
    INDEX_START: 'Punctuator',
    INDEX_END: 'Punctuator',
    '+': 'Punctuator',
    '=>': 'Punctuator',
    '->': 'Punctuator',
    ',': 'Punctuator',
    ':': 'Punctuator',
    '.': 'Punctuator',
    REGEX: 'RegularExpression',
    IDENTIFIER: 'Identifier',
    STRING: 'String'
  };

  getEspreeTokenType = function(type) {
    var ref;
    return (ref = espreeTokenTypes[type]) != null ? ref : type;
  };

  // extraTokensForESLint = (ast) ->
  //   extraTokens = []
  //   traverseBabylonAst ast, (node) ->
  //     return unless node
  //     {extra: {parenthesized} = {}, start, end} = node
  //     return unless parenthesized
  //     extraTokens.push
  //       type: '('
  //       value: '('
  //       start: start - 1
  //       end: start
  //     ,
  //       type: ')'
  //       value: ')'
  //       start: end
  //       end: end + 1
  //   extraTokens.sort ({start: firstStart}, {start: secondStart}) ->
  //     if firstStart < secondStart then -1 else 1
  // tokensForESLint = ({tokens, ast}) ->
  tokensForESLint = function({tokens}) {
    var locationData, token, type, value;
    // extraTokens = extraTokensForESLint ast
    // popExtraTokens = ({nextStart}) ->
    //   popped = []
    //   while (
    //     (nextExtra = extraTokens[0]) and
    //     (nextStart is 'END' or nextExtra.start < nextStart)
    //   )
    //     popped.push extraTokens.shift()
    //   popped
    return flatten([
      ...((function() {
        var i,
      len,
      ref,
      ref1,
      results;
// excluding INDENT/OUTDENT seems necessary to avoid eslint createIndexMap() potentially choking on comment/token with same start location
// espree doesn't seem to include tokens for \n
        results = [];
        for (i = 0, len = tokens.length; i < len; i++) {
          token = tokens[i];
          if (!(!token.generated && ((ref = token[0]) !== 'INDENT' && ref !== 'OUTDENT' && ref !== 'TERMINATOR'))) {
            continue;
          }
          [type,
      value,
      locationData] = token;
          results.push([
            {
              // ...popExtraTokens(nextStart: locationData.range[0])
              // ,
              type: getEspreeTokenType(type),
              value: (ref1 = value.original) != null ? ref1 : value.toString(),
              ...locationDataToAst(locationData)
            }
          ]);
        }
        return results;
      })()),
      {}
    ]);
  };

  // ...popExtraTokens(nextStart: 'END')
  exports.getParser = getParser = function(getAstAndTokens) {
    return function(code, opts) {
      var ast, comment, commentIndex, commentLocs, i, len, ref, ref1, tokens;
      // patchCodePathAnalysis()
      ({ast, tokens} = getAstAndTokens(code, opts));
      ast.tokens = tokensForESLint({tokens});
      extendVisitorKeys();
      commentLocs = (function() {
        var i, len, ref, ref1, results;
        ref1 = (ref = ast.comments) != null ? ref : [];
        results = [];
        for (i = 0, len = ref1.length; i < len; i++) {
          comment = ref1[i];
          results.push({
            start: {...comment.loc.start},
            end: {...comment.loc.end}
          });
        }
        return results;
      })();
      babylonToEspree(ast, babelTraverse, babylonTokenTypes, code);
      ref1 = (ref = ast.comments) != null ? ref : [];
      // babylonToEspree seems to like to change the file-leading comment's start line
      for (commentIndex = i = 0, len = ref1.length; i < len; commentIndex = ++i) {
        comment = ref1[commentIndex];
        comment.loc = commentLocs[commentIndex];
      }
      return {
        // dump espreeAst: ast
        ast,
        scopeManager: analyzeScope(ast, opts),
        visitorKeys: {
          ...KEYS,
          For: ['index', 'name', 'guard', 'step', 'source', 'body']
        },
        // Identifier: [...KEYS.Identifier, 'declaration']
        CodePathAnalyzer
      };
    };
  };

  exports.parseForESLint = getParser(function(code, opts) {
    return CoffeeScript.ast(code, {
      ...opts,
      withTokens: true
    });
  });

  // dump = (obj) -> console.log require('util').inspect obj, no, null

}).call(this);
