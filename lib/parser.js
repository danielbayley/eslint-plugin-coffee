// Generated by CoffeeScript 2.3.1
(function() {
  var CoffeeScript, analyzeScope, babelTraverse, babylonToEspree, babylonTokenTypes, dump, espreeTokenTypes, extendVisitorKeys, extraTokensForESLint, flatten, getEspreeTokenType, getParser, locationDataToAst, tokensForESLint, traverseBabylonAst;

  CoffeeScript = require('coffeescript');

  ({locationDataToAst, traverseBabylonAst} = require('coffeescript/lib/coffeescript/helpers'));

  // babylonToEspree = require '../node_modules/babel-eslint/babylon-to-espree'
  babylonToEspree = require('babel-eslint/babylon-to-espree');

  babelTraverse = require('babel-traverse').default;

  babylonTokenTypes = require('babylon').tokTypes;

  ({flatten} = require('lodash'));

  // patchCodePathAnalysis = require './patch-code-path-analysis'
  analyzeScope = require('./analyze-scope');

  extendVisitorKeys = function() {
    var t;
    t = require('babel-types');
    t.VISITOR_KEYS.For = ['index', 'name', 'step', 'guard', 'body'];
    return (t.VISITOR_KEYS.InterpolatedRegExpLiteral = ['expressions']);
  };

  espreeTokenTypes = {
    '{': 'Punctuator',
    '}': 'Punctuator',
    '[': 'Punctuator',
    ']': 'Punctuator',
    '(': 'Punctuator',
    ')': 'Punctuator',
    CALL_START: 'Punctuator',
    CALL_END: 'Punctuator',
    INDEX_START: 'Punctuator',
    INDEX_END: 'Punctuator',
    '+': 'Punctuator',
    REGEX: 'RegularExpression'
  };

  getEspreeTokenType = function(type) {
    var ref;
    return (ref = espreeTokenTypes[type]) != null ? ref : type;
  };

  extraTokensForESLint = function(ast) {
    var extraTokens;
    return [];
    extraTokens = [];
    traverseBabylonAst(ast, function(node) {
      var end, parenthesized, start;
      if (!node) {
        return;
      }
      ({
        extra: {parenthesized} = {},
        start,
        end
      } = node);
      if (!parenthesized) {
        return;
      }
      return extraTokens.push({
        type: '(',
        value: '(',
        start: start - 1,
        end: start
      }, {
        type: ')',
        value: ')',
        start: end,
        end: end + 1
      });
    });
    return extraTokens.sort(function({
        start: firstStart
      }, {
        start: secondStart
      }) {
      if (firstStart < secondStart) {
        return -1;
      } else {
        return 1;
      }
    });
  };

  tokensForESLint = function({tokens, ast}) {
    var extraTokens, locationData, popExtraTokens, token, type, value;
    extraTokens = extraTokensForESLint(ast);
    popExtraTokens = function({nextStart}) {
      var nextExtra, popped;
      popped = [];
      while ((nextExtra = extraTokens[0]) && (nextStart === 'END' || nextExtra.start < nextStart)) {
        popped.push(extraTokens.shift());
      }
      return popped;
    };
    return flatten([
      ...((function() {
        var i,
      len,
      ref,
      ref1,
      results;
// excluding INDENT/OUTDENT seems necessary to avoid eslint createIndexMap() potentially choking on comment/token with same start location
// espree doesn't seem to include tokens for \n
        results = [];
        for (i = 0, len = tokens.length; i < len; i++) {
          token = tokens[i];
          if (!(!token.generated && ((ref = token[0]) !== 'INDENT' && ref !== 'OUTDENT' && ref !== 'TERMINATOR'))) {
            continue;
          }
          [type,
      value,
      locationData] = token;
          results.push([
            ...popExtraTokens({
              nextStart: locationData.range[0]
            }),
            {
              type: getEspreeTokenType(type),
              value: (ref1 = value.original) != null ? ref1 : value.toString(),
              ...locationDataToAst(locationData)
            }
          ]);
        }
        return results;
      })()),
      ...popExtraTokens({
        nextStart: 'END'
      }),
      {}
    ]);
  };

  exports.getParser = getParser = function(getAstAndTokens) {
    return function(code, opts) {
      var ast, firstCommentLine, ref, ref1, ref2, ref3, tokens;
      // patchCodePathAnalysis()
      ({ast, tokens} = getAstAndTokens(code, opts));
      ast.tokens = tokensForESLint({tokens, ast});
      extendVisitorKeys();
      firstCommentLine = (ref = ast.comments) != null ? (ref1 = ref[0]) != null ? ref1.loc.start.line : void 0 : void 0;
      babylonToEspree(ast, babelTraverse, babylonTokenTypes, code);
      // babylonToEspree seems to like to change the file-leading comment's start line
      if ((ref2 = ast.comments) != null) {
        if ((ref3 = ref2[0]) != null) {
          ref3.loc.start.line = firstCommentLine;
        }
      }
      return {
        // dump espreeAst: ast
        ast,
        scopeManager: analyzeScope(ast, opts)
      };
    };
  };

  exports.parseForESLint = getParser(function(code, opts) {
    return CoffeeScript.ast(code, {
      ...opts,
      withTokens: true
    });
  });

  dump = function(obj) {
    return console.log(require('util').inspect(obj, false, null));
  };

}).call(this);
