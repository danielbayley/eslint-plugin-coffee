// Generated by CoffeeScript 2.3.1
(function() {
  /**
   * @fileoverview Tests for max-lines-per-function rule.
   * @author Pete Ward <peteward44@gmail.com>
   */
  'use strict';
  var RuleTester, rule, ruleTester;

  //------------------------------------------------------------------------------
  // Requirements
  //------------------------------------------------------------------------------
  rule = require('../../rules/max-lines-per-function');

  ({RuleTester} = require('eslint'));

  //------------------------------------------------------------------------------
  // Tests
  //------------------------------------------------------------------------------
  ruleTester = new RuleTester({
    parser: '../../..'
  });

  ruleTester.run('max-lines-per-function', rule, {
    valid: [
      {
        // Test code in global scope doesn't count
        code: 'x = 5\nx = 2',
        options: [1]
      },
      {
        // Test single line standlone function
        code: 'name = ->',
        options: [1]
      },
      {
        // Test standalone function with lines of code
        code: '->\n  x = 5\n  x = 2',
        options: [3]
      },
      {
        // skipBlankLines: false with simple standalone function
        code: '->\n  x = 5\n\n\n\n  x = 2',
        options: [
          {
            max: 6,
            skipComments: false,
            skipBlankLines: false
          }
        ]
      },
      {
        // skipBlankLines: true with simple standalone function
        code: '->\n  x = 5\n  \n  \n  \n  x = 2',
        options: [
          {
            max: 4,
            skipComments: false,
            skipBlankLines: true
          }
        ]
      },
      {
        // skipComments: true with an individual single line comment
        code: '->\n  x = 5\n  x = 2 # end of line comment',
        options: [
          {
            max: 3,
            skipComments: true,
            skipBlankLines: false
          }
        ]
      },
      {
        // skipComments: true with an individual single line comment
        code: '->\n  x = 5\n  # a comment on it\'s own line\n  x = 2\n  # end of line comment',
        options: [
          {
            max: 4,
            skipComments: true,
            skipBlankLines: false
          }
        ]
      },
      {
        // skipComments: true with single line comments
        code: '->\n  x = 5\n  # a comment on it\'s own line\n  # and another line comment\n  x = 2 # end of line comment',
        options: [
          {
            max: 4,
            skipComments: true,
            skipBlankLines: false
          }
        ]
      },
      {
        // skipComments: true test with multiple different comment types
        code: '->\n  x = 5\n  ### a \n    multi \n    line \n    comment \n  ###\n\n  x = 2 # end of line comment',
        options: [
          {
            max: 5,
            skipComments: true,
            skipBlankLines: false
          }
        ]
      },
      {
        // skipComments: true with multiple different comment types, including trailing and leading whitespace
        code: '->\n  x = 5\n  ### a comment with leading whitespace ###\n  ### a comment with trailing whitespace ### \n  ### a comment with trailing and leading whitespace ### \n  ### a \n    multi \n    line \n    comment \n  ###\n\n  x = 2 # end of line comment',
        options: [
          {
            max: 5,
            skipComments: true,
            skipBlankLines: false
          }
        ]
      },
      {
        // Multiple params on seperate lines test
        code: '(\n  aaa = 1,\n  bbb = 2,\n  ccc = 3\n) ->\n  return aaa + bbb + ccc',
        options: [
          {
            max: 7,
            skipComments: true,
            skipBlankLines: false
          }
        ]
      },
      {
        // IIFE validity test
        code: '(\n  ->\n    a\n    b\n    c\n)()',
        options: [
          {
            max: 4,
            skipComments: true,
            skipBlankLines: false,
            IIFEs: true
          }
        ]
      },
      {
        code: 'do (\n  ->\n    a\n    b\n    c\n)',
        options: [
          {
            max: 4,
            skipComments: true,
            skipBlankLines: false,
            IIFEs: true
          }
        ]
      },
      {
        // Nested function validity test
        code: "->\n  x = 0\n  nested = ->\n    y = 0\n    x = 2\n    if x is y\n      x++",
        options: [
          {
            max: 7,
            skipComments: true,
            skipBlankLines: false
          }
        ]
      },
      {
        // Class method validity test
        code: "class foo\n  method: ->\n    y = 10\n    x = 20\n    y + x",
        options: [
          {
            max: 4,
            skipComments: true,
            skipBlankLines: false
          }
        ]
      },
      {
        // IIFEs should be recognised if IIFEs: true
        code: "do ->\n  x = 0\n  y = 0\n  z = x + y\n  foo = {}\n  bar",
        options: [
          {
            max: 6,
            skipComments: true,
            skipBlankLines: false,
            IIFEs: true
          }
        ]
      },
      {
        // IIFEs should not be recognised if IIFEs: false
        code: "do ->\n  x = 0\n  y = 0\n  z = x + y\n  foo = {}\n  bar",
        options: [
          {
            max: 2,
            skipComments: true,
            skipBlankLines: false,
            IIFEs: false
          }
        ]
      }
    ],
    invalid: [
      {
        // Test simple standalone function is recognised
        code: '->\n  a',
        options: [1],
        errors: ['function has too many lines (2). Maximum allowed is 1.']
      },
      {
        // Test anonymous function assigned to variable is recognised
        code: 'func = ->\n  a',
        options: [1],
        errors: ["function 'func' has too many lines (2). Maximum allowed is 1."]
      },
      {
        // Test arrow functions are recognised
        code: 'bar = () =>\n  x = 2 + 1\n  return x',
        options: [2],
        errors: ["function 'bar' has too many lines (3). Maximum allowed is 2."]
      },
      {
        // Test skipBlankLines: false
        code: '->\n  x = 5\n\n\n  \n\n  x = 2',
        options: [
          {
            max: 6,
            skipComments: false,
            skipBlankLines: false
          }
        ],
        errors: ['function has too many lines (7). Maximum allowed is 6.']
      },
      {
        // Test skipBlankLines: false with CRLF line endings
        code: '->\r\n  x = 5\r\n\t\r\n \r\n\r\n\r\n  x = 2\r\n',
        options: [
          {
            max: 6,
            skipComments: true,
            skipBlankLines: false
          }
        ],
        errors: ['function has too many lines (7). Maximum allowed is 6.']
      },
      {
        // Test skipBlankLines: true
        code: 'name = ->\n  x = 5\n  \n  \n  \n  x = 2',
        options: [
          {
            max: 2,
            skipComments: true,
            skipBlankLines: true
          }
        ],
        errors: ["function 'name' has too many lines (3). Maximum allowed is 2."]
      },
      {
        // Test skipBlankLines: true with CRLF line endings
        code: '->\r\n  x = 5\r\n\t\r\n \r\n\r\n  x = 2\r\n',
        options: [
          {
            max: 2,
            skipComments: true,
            skipBlankLines: true
          }
        ],
        errors: ['function has too many lines (3). Maximum allowed is 2.']
      },
      {
        // Test skipComments: true and skipBlankLines: false for multiple types of comment
        code: 'name = -> # end of line comment\n  x = 5 ### mid line comment ###\n  # single line comment taking up whole line\n\n\n\n\n  x = 2',
        options: [
          {
            max: 6,
            skipComments: true,
            skipBlankLines: false
          }
        ],
        errors: ["function 'name' has too many lines (7). Maximum allowed is 6."]
      },
      {
        // Test skipComments: true and skipBlankLines: true for multiple types of comment
        code: 'name = -> # end of line comment\n  x = 5 ### mid line comment ###\n  # single line comment taking up whole line\n\n  \n  \n  x = 2',
        options: [
          {
            max: 1,
            skipComments: true,
            skipBlankLines: true
          }
        ],
        errors: ["function 'name' has too many lines (3). Maximum allowed is 1."]
      },
      {
        // Test skipComments: false and skipBlankLines: true for multiple types of comment
        code: 'name = -> # end of line comment\n  x = 5 ### mid line comment ###\n  # single line comment taking up whole line\n\n  \n  \n  x = 2',
        options: [
          {
            max: 1,
            skipComments: false,
            skipBlankLines: true
          }
        ],
        errors: ["function 'name' has too many lines (4). Maximum allowed is 1."]
      },
      {
        // Test simple standalone function with params on separate lines
        code: "foo = (\n  aaa = 1,\n  bbb = 2,\n  ccc = 3\n) ->\n  return aaa + bbb + ccc",
        options: [
          {
            max: 2,
            skipComments: true,
            skipBlankLines: false
          }
        ],
        errors: ["function 'foo' has too many lines (6). Maximum allowed is 2."]
      },
      {
        // Test IIFE "function" keyword is included in the count
        code: "(\n  ->\n    a\n\n    b\n)()",
        options: [
          {
            max: 2,
            skipComments: true,
            skipBlankLines: false,
            IIFEs: true
          }
        ],
        errors: ['function has too many lines (4). Maximum allowed is 2.']
      },
      {
        code: "do ->\n  a\n\n  b",
        options: [
          {
            max: 2,
            skipComments: true,
            skipBlankLines: false,
            IIFEs: true
          }
        ],
        errors: ['function has too many lines (4). Maximum allowed is 2.']
      },
      {
        // Test nested functions are included in it's parent's function count.
        code: "parent = ->\n  x = 0\n\n  nested = ->\n    y = 0\n\n    x = 2\n\n  if x is y\n    x++",
        options: [
          {
            max: 9,
            skipComments: true,
            skipBlankLines: false
          }
        ],
        errors: ["function 'parent' has too many lines (10). Maximum allowed is 9."]
      },
      {
        // Test nested functions are included in it's parent's function count.
        code: "parent = ->\n  x = 0\n  nested = ->\n    y = 0\n    x = 2\n  if x is y\n    x++",
        options: [
          {
            max: 2,
            skipComments: true,
            skipBlankLines: false
          }
        ],
        errors: ["function 'parent' has too many lines (7). Maximum allowed is 2.",
      "function 'nested' has too many lines (3). Maximum allowed is 2."]
      },
      {
        // Test regular methods are recognised
        code: "class foo\n  method: ->\n    y = 10\n    x = 20\n    y + x",
        options: [
          {
            max: 2,
            skipComments: true,
            skipBlankLines: false
          }
        ],
        errors: ["method 'method' has too many lines (4). Maximum allowed is 2."]
      },
      {
        // Test static methods are recognised
        code: "class A\n  @foo: (a) ->\n\n    a",
        options: [
          {
            max: 2,
            skipComments: true,
            skipBlankLines: false
          }
        ],
        errors: ["static method 'foo' has too many lines (3). Maximum allowed is 2."]
      },
      {
        // Test computed property names
        code: "class A\n  [foo +\n          bar\n  ]: (a) ->\n    a",
        options: [
          {
            max: 2,
            skipComments: true,
            skipBlankLines: false
          }
        ],
        errors: ['method has too many lines (4). Maximum allowed is 2.']
      },
      {
        // Test the IIFEs option includes IIFEs
        code: "do (x) ->\n  x = 0\n  y = 0\n  z = x + y\n  foo = {}\n  bar",
        options: [
          {
            max: 2,
            skipComments: true,
            skipBlankLines: false,
            IIFEs: true
          }
        ],
        errors: ['function has too many lines (6). Maximum allowed is 2.']
      }
    ]
  });

}).call(this);
