// Generated by CoffeeScript 2.3.1
(function() {
  /**
   * @fileoverview Tests for prefer-spread rule.
   * @author Toru Nagashima
   */
  'use strict';
  var RuleTester, errors, rule, ruleTester;

  //------------------------------------------------------------------------------
  // Requirements
  //------------------------------------------------------------------------------
  rule = require('eslint/lib/rules/prefer-spread');

  ({RuleTester} = require('eslint'));

  //------------------------------------------------------------------------------
  // Tests
  //------------------------------------------------------------------------------
  errors = [
    {
      message: "Use the spread operator instead of '.apply()'.",
      type: 'CallExpression'
    }
  ];

  ruleTester = new RuleTester({
    parser: '../../..'
  });

  ruleTester.run('prefer-spread', rule, {
    valid: [
      'foo.apply(obj, args)',
      'obj.foo.apply null, args',
      'obj.foo.apply(otherObj, args)',
      'a.b(x, y).c.foo.apply(a.b(x, z).c, args)',
      'a.b.foo.apply(a.b.c, args)',
      // ignores non variadic.
      'foo.apply(undefined, [1, 2])',
      'foo.apply(null, [1, 2])',
      'obj.foo.apply(obj, [1, 2])',
      // ignores computed property.
      'apply = null\nfoo[apply](null, args)',
      // ignores incomplete things.
      'foo.apply()',
      'obj.foo.apply()',
      'obj.foo.apply(obj, ...args)'
    ],
    invalid: [
      {
        code: 'foo.apply(undefined, args)',
        output: 'foo(...args)',
        errors
      },
      {
        code: 'foo.apply(null, args)',
        output: 'foo(...args)',
        errors
      },
      {
        code: 'obj.foo.apply(obj, args)',
        output: 'obj.foo(...args)',
        errors
      },
      {
        code: 'obj.foo.apply obj, args',
        output: 'obj.foo(...args)',
        errors
      },
      {
        // Not fixed: a.b.c might activate getters
        code: 'a.b.c.foo.apply(a.b.c, args)',
        output: null,
        errors
      },
      {
        // Not fixed: a.b(x, y).c might activate getters
        code: 'a.b(x, y).c.foo.apply(a.b(x, y).c, args)',
        output: null,
        errors
      },
      {
        // Not fixed (not an identifier)
        code: '[].concat.apply([ ], args)',
        output: null,
        errors
      },
      {
        // Not fixed (not an identifier)
        code: '[].concat.apply([\n  ###empty###\n], args)',
        output: null,
        errors
      }
    ]
  });

}).call(this);
